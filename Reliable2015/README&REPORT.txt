可靠传输实现报告
学号:	5130309062
姓名:	高宇
1. 概述
	在reliable.c中, 按照作业要求实现了支持停等待(stop and wait)和滑动窗口(sliding window)的可靠传输协议, 并通过了所有测试.
2. 协议
	下面简单介绍reliable.c中隐含的协议:
	(1). 协议使用基本的UDP数据包, 包括普通的数据包和确认数据包(ack packet), 来进行数据的传输和确认. 在一方发起连接后, 两侧均可独立地发送数据. 当双方数据发送结束时, 连接断开. 双方对于损毁(长度不对, 校验和不对)的数据包均直接忽略.
	(2). 连接的建立: 连接建立不需要额外的步骤. 但我们约定两方发送的数据的序列号(sequence number)都从1开始编号以确定数据的开始.
	(3). 数据的传送: 当没有数据损坏和丢失的情况下, 等同于滑动窗口方法. 即发送方按顺序发送数据包, 但放出且未确认的数据包始终不超过窗口大小. 接收方使用累积确认(cumulative ack).
	(4). 数据的重发: 发送方距离序列号最小的未被确认的包的发出经过一定时间(time out)时, 应认为包丢失或损坏, 重发该包并重置计时器. 接收方收到重复的数据包, 应考虑确认数据包没有成功发送, 所以应重新发送一个确认数据包以确认收到的全部数据. 除此之外没有其他重发的情况.
	(5). 连接的结束: 每一方发送的数据包的最后一个都应该是一个EOF数据包, 长度为12, 即data长度为0的UDP数据包. 当一方收到对方的EOF数据包, 且自己发出的EOF数据包被确认后, 方可结束连接. 这里需要对于一个场景做出解释: 如果一方A收到对方B的EOF数据包后结束, 但他发出的对于EOF数据包的确认没有被对方B收到, 这将导致对方B一直重发数据包. 然而由于A正常结束, 说明A已经收到了B关于A发出的EOF数据包的确认, 即B已经收到了A的全部数据并输出了EOF. 此时由rlib.c结束连接, 所以并没有在reliable.c中处理这个情况.
3. 开发的过程
	总共用时在10小时以内. 其中一半用于理解rlib.c, rlib.h和linux提供的接口. 10%用于写代码. 10%用于调试. 20%用于发现rlib.c中的一个问题(当我每次只输出一个字符时, rlib.c频繁调用linux的write()导致概率性出错).